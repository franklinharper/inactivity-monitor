import com.franklinharper.inactivitymonitor.ActivityType;

-- The table name "activity" would have been simpler than userActivity, but unfortunately it is already
-- used by the Android SDK for one of its main components, so using Activity would have been confusing.
CREATE TABLE userActivity (
  id INTEGER PRIMARY KEY,
  -- ActivityType enum: e.g. STILL, WALKING, etc.
  type TEXT AS ActivityType NOT NULL,
  -- activity type Int value as received from Google's ActivityRecognition API
  transition_activity_type INTEGER AS Int,

  -- The unix time when this Activity started (see comments below for details)
  start INTEGER NOT NULL DEFAULT (strftime('%s','now'))
    --
    -- "Start" is used for local datetime calculations (e.g. select today's Activities).
    --
    --- It is NOT used to ensure a strict ordering of UserActivities, the "id" is used for that purpose.
    --
    -- In certain edge-cases the "start" values may not monotonically increase
    --
    -- For example:
    --   * the system admin changes the system clock
    --   * there is a configuration error
    --
    -- In this case, these edge-cases can safely be ignored because they would NOT affect the ordering of events
    -- which is ensured by the "id".
    --
    -- More info at https://en.wikipedia.org/wiki/Unix_time
);

CREATE INDEX activity_start ON userActivity(start);

selectAll:
SELECT *
FROM userActivity;

selectLatest:
SELECT *
FROM userActivity
ORDER BY id DESC LIMIT 1;

selectRange:
SELECT *
FROM userActivity
WHERE start >= :startInclusive
      AND start < :endExclusive
ORDER BY id DESC;

selectStarting:
SELECT *
FROM userActivity
WHERE start >= :startInclusive
ORDER BY id DESC;

insert:
-- The values for id and start columns are set by SQLite using default values, so that when a row is inserted:
--
--   * Id is an integer that is one larger than the largest rowid in the table, or 1 when the table is empty
--   * Start is the current unix time stamp in seconds
--
INSERT INTO userActivity(type, transition_activity_type)
VALUES (?, ?);

-- The LAG function could be used for calculating Activity durations in SQL
--  LAG (activity_type, 1) OVER (ORDER BY timestamp) previous_timestamp
-- transitionsForCurrentActivity:
-- SELECT
--   timestamp
--   , activity_type
--   , transition_type
--   , LAG (activity_type) AS previous_timestamp
-- FROM userActivityTransition
-- WHERE activity_type = previous_timestamp
-- ORDER BY timestamp DESC;

